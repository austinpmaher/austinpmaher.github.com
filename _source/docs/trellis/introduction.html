<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Generator" CONTENT="Microsoft Word 97">
   <META NAME="Template" CONTENT="C:\msoffice\Templates\APM-DOC.DOT">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>An Introduction to Trellis/Owl</TITLE>
</HEAD>
<BODY>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>&nbsp;</FONT></FONT>
<CENTER><B><FONT FACE="Arial"><FONT SIZE=+1>An Introduction to Trellis/Owl</FONT></FONT></B></CENTER>

<CENTER><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Craig Schaffert, Topher
Cooper, Bruce Bullis,</FONT></FONT></CENTER>

<CENTER><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Mike Kilian, and Carrie
Wilpolt</FONT></FONT></CENTER>

<CENTER><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Digital Equipment
Corporation</FONT></FONT></CENTER>

<CENTER><FONT FACE="Bookman Old Style"><FONT SIZE=-1>77 Reed Road, HLO2-3/M08</FONT></FONT></CENTER>

<CENTER><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Hudson, MA 01749</FONT></FONT></CENTER>

<CENTER><FONT FACE="Bookman Old Style"><FONT SIZE=-1>(617)568-5627</FONT></FONT></CENTER>


<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>&nbsp;</FONT></FONT>

<P><B><FONT FACE="Arial">Abstract</FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Trellis/Owl is an object-based
language incorporating a type hierarchy with multiple inheritance and compile-time
type checking. The combination of features in the language facilitates
the design, implementation, and evolution of large computer programs. This
paper provides an brief introduction to the Trellis/Owl language. It discusses
the basic elements of the language, objects, and shows how these are specified
and implemented using <I>types</I>, <I>operations</I>, and <I>components</I>.
The notion of a type hierarchy is introduced by a discussion of <I>subtyping</I>
and <I>inheritance</I>. Other elements of the Trellis/Owl language such
as <I>type generators</I>, <I>iterators</I>, and <I>exceptions</I> are
briefly presented.</FONT></FONT>

<P><B><FONT FACE="Arial">Acknowledgements</FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>The Trellis/Owl language
was designed by Topher Cooper and Craig Schaffert. In addition to the authors,
other current project members are Dan Halbert and Pat O'Brien. Ken King
is the group manager. During the past four years, several other Digital
employees and outside consultants have made contributions to the language.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Permission to copy without
fee all or part of this material is granted provided that the copies are
not made or distributed for direct commercial advantage, the ACM copyright
notice and the title of the publication and its date appear, and notice
is given that copying is by permission of the Association for Computing
Machinery. To copy otherwise, or to republish, requires a fee and/or specific
permission.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>&copy;1986 ACM 0-89791-204-7/86/0900-0009
75&cent;</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Introduction</FONT></FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>For the past four years
the Object-Based Systems Group has been investigating object-based programming
methodology. As a part of this research project, an object-oriented language
was developed and is being used inside Digital. This effort has been expanded
to include the design and development of a complete object-based programming
environment called Trellis based upon and implemented in the language Trellis/Owl.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Trellis/Owl is an object-based
language which integrates the strengths of previous work in the area of
object-oriented programming. Sinailtalk-80 [Goldberg 83] has demonstrated
the power of the "message passing" metaphor and inheritance hierarchies
for rapid and convenient prototyping. The Flavors package for Zeta Lisp
[Weinreb 81] as well as some variants of Smalltalk-80 (e.g., [Borning 821])
have demonstrated the additional power provided by multiple inheritance.
The CLU language [Liskov 77][Liskov 81] has shown that an object-oriented
language could provide good performance, and, by providing strict type-checking
and type-abstraction features, could actively support the programming goals
of high reliability and maintainability.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Trellis/Owl combines a
multiple-inheritance type hierarchy with strict, compile-time type checking.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>The combination of features
in Trellis/Owl facilitates the design, implementation, and evolution of
large computer programs. The notion of types and a type hierarchy allows
the program design to be documented and conveyed to future maintainers.
The compile-time type checking insures the correct usage of types and helps
eliminate many common programming errors.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Trellis/Owl uses a conventional
programming language syntax and employs standard procedure call notation
to invoke operations on objects. We believe this makes the language easier
to learn. A predefined library, provided as part of the language, supplies
the standard initial types such as integers, strings, and arrays.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>The rest of this paper
presents a brief introduction to the Trellis/Owl language&middot; It discusses
the basic elements of the language, objects, and shows how these are specified
and implemented using <I>types</I>, <I>operations</I>, and <I>components</I>.
The notion of a type hierarchy is introduced by a discussion of <I>subtyping</I>
and <I>inheritance</I>&middot; Other elements of the Trellis/Owl language
such as <I>type generators</I>, <I>iterators</I>, and <I>exceptions</I>
are briefly presented.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Types</FONT></FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>In object-oriented languages,
objects with similar behavior are grouped into <I>types</I> (<I>classes</I>)
and are known as <I>instances</I> of their type. A type characterizes'
the behavior of its instances by describing the operations that can manipulate
those objects&middot; Objects with the same type have the same operations.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>In Trellis/Owl, programs
are built by defining <I>types</I>&middot; A <I>type module</I> declares
a type; it groups together the operations and other definitions that describe
the behavior of the type.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Consider the type </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">.
Instances of this type are distinct windows on a display screen, which
have certain behavior in common- Operations such as </FONT><B><FONT FACE="Courier New">display</FONT></B><FONT FACE="Bookman Old Style">,
</FONT><B><FONT FACE="Courier New">create</FONT></B><FONT FACE="Bookman Old Style">,
</FONT><B><FONT FACE="Courier New">move</FONT></B><FONT FACE="Bookman Old Style">,
</FONT><B><FONT FACE="Courier New">erase</FONT></B><FONT FACE="Bookman Old Style">,
and </FONT><B><FONT FACE="Courier New">get_position</FONT></B><FONT FACE="Bookman Old Style">
are defined in type module </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">.
The operations in </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
determine how windows can be manipulated.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>There are two views of
a type: the specification and the implementation. The <I>client</I> of
a type only needs to know the <I>specification</I> of the type. This external
view of the type describes what operations are available for the type and
how the operations may be used, but not how those operations accomplish
their specified behavior.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>In contrast, the <I>implementation</I>
of the type is an internal view, describing how the objects of that type
are represented and how each operation is actually implemented in terms
of that representation&middot; The implementation may include ancillary
operations or other definitions that exist only to help realize the external
view of the type. We will touch on additional aspects of this internal
view of the type in the next few sections.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Operations</FONT></FONT></B>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">In Trellis/Owl, objects
are manipulated only by operations. For instance, to display a </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">,
one invokes the </FONT><B><FONT FACE="Courier New">display</FONT></B><FONT FACE="Bookman Old Style">
operation:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>display (this_window. some_position)</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">The first argument, </FONT><B><FONT FACE="Courier New">this_window</FONT></B><FONT FACE="Bookman Old Style">,
is called the <I>controlling object</I>. An operation is applied to the
controlling object, whose type determines the code to be invoked. Different
types can have an operation with the same name. Suppose that types </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">
and </FONT><B><FONT FACE="Courier New">String</FONT></B><FONT FACE="Bookman Old Style">
have a </FONT><B><FONT FACE="Courier New">print</FONT></B><FONT FACE="Bookman Old Style">
operation.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>var i: Integer;
var e: String;
var z: Integer | String;

print (i);
print (s);
print (z);</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><B><FONT FACE="Courier New">Print</FONT></B><FONT FACE="Bookman Old Style">
applied to </FONT><B><FONT FACE="Courier New">i</FONT></B><FONT FACE="Bookman Old Style">
will invoke the print operation on integers. </FONT><B><FONT FACE="Courier New">Print</FONT></B><FONT FACE="Bookman Old Style">
applied to </FONT><B><FONT FACE="Courier New">s</FONT></B><FONT FACE="Bookman Old Style">
will invoke the print operation on strings. The variable </FONT><B><FONT FACE="Courier New">z</FONT></B><FONT FACE="Bookman Old Style">
can denote either an integer or a string- The appropriate </FONT><B><FONT FACE="Courier New">print</FONT></B><FONT FACE="Bookman Old Style">
operation will be selected at run-time depending on whether z currently
denotes an integer or a string.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">There are two kinds of
operations. <I>Instance</I> operations apply to individual instances of
a type. For example, </FONT><B><FONT FACE="Courier New">display</FONT></B><FONT FACE="Bookman Old Style">
and </FONT><B><FONT FACE="Courier New">move</FONT></B><FONT FACE="Bookman Old Style">
are instance operations that apply to windows. <I>Class</I> operations
apply to the type as a whole, not to a particular instance of the type.
Creation operations are a good example of class operation, since they produce
new objects rather than manipulating objects that already exist. For instance,
</FONT><B><FONT FACE="Courier New">create (Window)</FONT></B><FONT FACE="Bookman Old Style">,
which creates a new window, is a class operation and is applied to </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
itself.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">To fully define an operation,
the programmer must specify both an <I>interface</I> and an implementation.
The operation interface describes how the operation is called- It includes
the name of the operation, the number and types of the arguments, the type
of a return value (if any), and any exceptions that might be signalled.
For example, here is an interface for the operation </FONT><B><FONT FACE="Courier New">maximum</FONT></B><FONT FACE="Bookman Old Style">
in </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation maximum (me, other: Integer)
returns (Integer);</TT></B></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>If we add an implementation,
the operation might look like this:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation maximum (me, other: Integer)
returns (Integer)
is
begin
&nbsp;&nbsp;&nbsp; if me > other
&nbsp;&nbsp;&nbsp; then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return me;
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return other;
&nbsp;&nbsp;&nbsp; end if;
end;</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">The </FONT><B><FONT FACE="Courier New">me</FONT></B><FONT FACE="Bookman Old Style">
keyword indicates that </FONT><B><FONT FACE="Courier New">maximum</FONT></B><FONT FACE="Bookman Old Style">
is an instance operation. It is also used in the body of the implementation
to denote the controlling object.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Class operations use the
keyword mytype instead of me. Mytype emphasizes that the controlling object
is a type. For example, the interface for the create operation for windows
might look like this:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation create (mytype)
returns (mytype);</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">where </FONT><B><FONT FACE="Courier New">mytype</FONT></B><FONT FACE="Bookman Old Style">
denotes the type </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Variables are not objects;
they just denote objects. Assignment causes a variable to denote a new
object. When the value of one variable is assigned to another, they will
both denote the same object. No copying is done.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Arguments are local variables.
When an operation is invoked, the actual argument objects are assigned
to the corresponding local variables. Thus, the actual argument objects
are shared but the variables that the caller used to name the argument
objects are not.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Operations can be declared
to be <I>public</I> or <I>private</I>. Public operations are available
to the clients of a type. The specifications of these public operations
form the external view of the type. Private operations are intended for
use by the implementor of a type and are not available to clients of the
type. The private operations and the implementations of the public operations
form the internal view of a type.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Trellis/Owl allows the
programmer to use infix and prefix operators to invoke operations. For
example, to add two integers, </FONT><B><FONT FACE="Courier New">a</FONT></B><FONT FACE="Bookman Old Style">
and </FONT><B><FONT FACE="Courier New">b</FONT></B><FONT FACE="Bookman Old Style">,
one can use </FONT><B><FONT FACE="Courier New">a + b</FONT></B><FONT FACE="Bookman Old Style">.
At compile-time, these operators are replaced with standard invocations,
so </FONT><B><FONT FACE="Courier New">a + b</FONT></B><FONT FACE="Bookman Old Style">
</FONT><FONT FACE="Courier New">becomes <B>plus(a, b).</B></FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Components</FONT></FONT></B>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Frequently, objects have
distinct parts, similar to record fields or entity attributes. For instance,
consider the position of a </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
or the name of a </FONT><B><FONT FACE="Courier New">Person</FONT></B><FONT FACE="Bookman Old Style">.
For each such</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>part, we need a pair of
operations: one to get the part's value and one to modify its value.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Trellis/Owl has a shorthand
<I>selector</I> notation for accessing these parts. For example, a type
</FONT><B><FONT FACE="Courier New">Thermostat</FONT></B><FONT FACE="Bookman Old Style">
could have a celsius part. If </FONT><B><FONT FACE="Courier New">zonel</FONT></B><FONT FACE="Bookman Old Style">
is an object of type </FONT><B><FONT FACE="Courier New">Thermostat</FONT></B><FONT FACE="Bookman Old Style">,
then</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>zone1.celsius</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">i~ a short form for </FONT><B><FONT FACE="Courier New">get_celsius(zonel)</FONT></B><FONT FACE="Bookman Old Style">.
Similarly, when used on the left hand side of an assignment, as in</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>zonel.celsius := 21.0;</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">the selector notation is translated
to </FONT><B><FONT FACE="Courier New">put_celsius(zonel. 21 O)</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">The selector notation was
designed for use with Trellis/Owl <I>components</I>. Components provide
a short form for specifying and implementing the get and put operations
mentioned aboye,. For example, the specification of a component </FONT><B><FONT FACE="Courier New">celsius</FONT></B><FONT FACE="Bookman Old Style">
in type </FONT><B><FONT FACE="Courier New">Thermostat</FONT></B><FONT FACE="Bookman Old Style">
might look like:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>component me.celsius: Real;</TT></B></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>'l'he component specification
automatically creates specifications for get and put operations to examine
and modify the component:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation get_celsius (me)
returns (Real);

operation put_celsius (me, value: Real)
returns (Real);</TT></B></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>Since a component is just
a short form for a pair of operations, it must have an implementation.
One way of implementing a component is to declare it to be a <I>field</I>,
which means that there is an actual "slot" in the physical representation
of the object that will store the value for this component. For example,</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>component me.celsius: Real
is field;</TT></B></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>The get and put operations
for a field component are automatically generated to fetch from and store
to the correct slot in the object. The fields of an object, collected together,
form the physical storage for the object.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Alternatively, we can describe
the desired get and put behaviors in terms of other components or operations.
For example, we could specify and implement a component </FONT><B><FONT FACE="Courier New">fahrenheit</FONT></B><FONT FACE="Bookman Old Style">
in type module </FONT><B><FONT FACE="Courier New">Thermostat</FONT></B><FONT FACE="Bookman Old Style">
as follows:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>component me.fahrenheit: Real
get is
begin
&nbsp;&nbsp;&nbsp; return me.celsius * (9.0/5.0) + 32.0;
end;

put is
begin
&nbsp;&nbsp;&nbsp; me.celsius := (value - 32.0)*(5.0/9.0);
&nbsp;&nbsp;&nbsp; return value;
end;</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">We are free to choose which
components to implement as fields and which as computed values. Of course,
the user of the type does not see any distinction between components of
the type that are actually fields in the object and those that are computed
values. We could implement </FONT><B><FONT FACE="Courier New">fahrenheit</FONT></B><FONT FACE="Bookman Old Style">
as a field and compute </FONT><B><FONT FACE="Courier New">celsius</FONT></B><FONT FACE="Bookman Old Style">,
the reverse of the above, without altering the external view of the type.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">As with operations, we
can have both <I>instance</I> components, like those defined above, and
<I>class</I> components. To define a class component, we use </FONT><B><FONT FACE="Courier New">mytype</FONT></B><FONT FACE="Bookman Old Style">
in place of </FONT><B><FONT FACE="Courier New">me</FONT></B><FONT FACE="Bookman Old Style">
to represent the controlling object. For example, we might want to keep
track of the number of thermostats that are created. A class component
could be defined as follows:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>component mytype.count: Integer
put private
is field;</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">Since it may not make sense
to let the clients of </FONT><B><FONT FACE="Courier New">Thermostat</FONT></B><FONT FACE="Bookman Old Style">
modify this value, it has been made </FONT><B><FONT FACE="Courier New">put
private</FONT></B><FONT FACE="Bookman Old Style">. This means that the
put operation is a private operation and not available to clients. The
</FONT><B><FONT FACE="Courier New">count</FONT></B><FONT FACE="Bookman Old Style">
component could be incremented internally as part of the </FONT><B><FONT FACE="Courier New">create</FONT></B><FONT FACE="Bookman Old Style">
operation.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Subtyping</FONT></FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>In the previous sections
we described how individual types can be specified and implemented in isolation.
However, there are natural relationships between types which can be expressed
in Trellis/Owl.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Types describe behavior.
Some descriptions are more general than others. For example, the type </FONT><B><FONT FACE="Courier New">Employee</FONT></B><FONT FACE="Bookman Old Style">
might describe a general kind of employee- Objects of type </FONT><B><FONT FACE="Courier New">Employee</FONT></B><FONT FACE="Bookman Old Style">
have common properties such as names, social security numbers, and salaries.
One kind of employee is a postal worker. The type </FONT><B><FONT FACE="Courier New">Postal_Worker</FONT></B><FONT FACE="Bookman Old Style">
has all the behavior of </FONT><B><FONT FACE="Courier New">Employee</FONT></B><FONT FACE="Bookman Old Style">
and perhaps other properties specific to postal workers, such as being
a member of the postal union. To capture the notion that every postal worker
is also an employee, we say that </FONT><B><FONT FACE="Courier New">Postal_Worker</FONT></B><FONT FACE="Bookman Old Style">
is a <I>subtype</I> of </FONT><B><FONT FACE="Courier New">Employee</FONT></B><FONT FACE="Bookman Old Style">.
Conversely, we say that </FONT><B><FONT FACE="Courier New">Employee</FONT></B><FONT FACE="Bookman Old Style">
is a <I>supertype</I> of </FONT><B><FONT FACE="Courier New">Postal_Worker</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">The programmer uses subtyping
to organize the many types in a large program. It is easier to understand
</FONT><B><FONT FACE="Courier New">Postal_Worker</FONT></B><FONT FACE="Bookman Old Style">
after understanding </FONT><B><FONT FACE="Courier New">Employee</FONT></B><FONT FACE="Bookman Old Style">
because </FONT><B><FONT FACE="Courier New">Postal_Worker</FONT></B><FONT FACE="Bookman Old Style">
only specifies the differences between it and </FONT><B><FONT FACE="Courier New">Employee</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Let's look at another example:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>Window&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I0 Stream
&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /
&nbsp;&nbsp;&nbsp;&nbsp; Text_Window</TT></B></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>A window is a region on a
display screen with properties such as size and position; it may be moved,
erased or resized. A text window is ~ specialized window which displays
lines of characters- It too has a size, position, and may be moved, erased
and resized.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Programs may also read
text from or write text to a text window. These read and write operations
are the same as those required by an I/O stream. </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">
can therefore be thought of as a specialization of </FONT><B><FONT FACE="Courier New">I0_Stream</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Since </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">
has all the behavior of </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
as well as of </FONT><B><FONT FACE="Courier New">I0_Stream</FONT></B><FONT FACE="Bookman Old Style">,
</FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">
is a subtype of both.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Here is another example
of a subtype relationship. A dictionary associates a key with some value,
and has a lookup operation that returns the key corresponding to a given
value. For relatively few values, a linear list may be a good way of representing
a dictionary. For larger numbers of values, it may be more efficient to
use a hash table. Both implementations provide the same visible </FONT><B><FONT FACE="Courier New">Dictionary</FONT></B><FONT FACE="Bookman Old Style">
behavior:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dictionary
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \
Linear_List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hash_Table</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">Subtyping is based on behavior,
not implementation. </FONT><B><FONT FACE="Courier New">TextWindow</FONT></B><FONT FACE="Bookman Old Style">'s
read operation may he implemented quite differently than </FONT><B><FONT FACE="Courier New">I0_Stream</FONT></B><FONT FACE="Bookman Old Style">'s.
Lookup on </FONT><B><FONT FACE="Courier New">Linear_List</FONT></B><FONT FACE="Bookman Old Style">
would use a different algorithm than lookup on </FONT><B><FONT FACE="Courier New">Hash_Table</FONT></B><FONT FACE="Bookman Old Style">.
Both lookup operations find a value based on a key, but the way they went
about achieving that behavior would be different.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Because subtyping is based
on visible behavior, we say that Trellis/Owl has a <I>specification hierarchy</I>
as contrasted with Smalltalk's <I>implementation hierarchy</I>. Given a
type S which is a subtype of a type T, then any object of type S behaves
like a T object and may be used wherever a T object may be used.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>T
|
S</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">Since </FONT><B><FONT FACE="Courier New">S</FONT></B><FONT FACE="Bookman Old Style">
objects behave like </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">
objects, </FONT><B><FONT FACE="Courier New">S</FONT></B><FONT FACE="Bookman Old Style">
objects can be assigned to a variable of type </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">.
Consider:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>var tw: Text_Window;
var io: I0_Stream;
io := tw;
read_line (io); </TT></B><I><TT>! We can read from a Text_Window.</TT></I></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">This is acceptable. A text
window is a type of I/O stream so it is safe to assign it to an </FONT><B><FONT FACE="Courier New">I0_Stream</FONT></B><FONT FACE="Bookman Old Style">
variable. The following is not acceptable.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>var tw: Text_Window;
var io: IO_Stream;
tw := io; </TT></B><TT><I>! This is an error since IO_Streams
</I><B>move (tw, new_place); </B><I>! are net generally movable.</I></TT></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>The compiler will warn that
the assignment is in error, since</FONT></FONT><I> </I><FONT SIZE=-1><B><FONT FACE="Courier New">I0_Stream</FONT></B><FONT FACE="Bookman Old Style">
is not declared as a subtype of </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">This definition of subtyping
also implies strong constraints on what operations can be defined in </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">
and </FONT><B><FONT FACE="Courier New">S</FONT></B><FONT FACE="Bookman Old Style">.
Let's look at an operation defined on the supertype </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation F (me, a: Atype<SUB>T</SUB>) returns (RType<SUB>T</SUB>)</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
may be applied to any </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">
object and takes an argument of type </FONT><B><FONT FACE="Courier New">Atype<SUB>T</SUB></FONT></B><FONT FACE="Bookman Old Style">.
The operation guarantees to return an object of type </FONT><B><FONT FACE="Courier New">Rtype<SUB>T</SUB></FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">If an </FONT><B><FONT FACE="Courier New">S</FONT></B><FONT FACE="Bookman Old Style">
object is to behave as a </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">
object, </FONT><B><FONT FACE="Courier New">S</FONT></B><FONT FACE="Bookman Old Style">
must have an operation </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
which accepts at least the same type of argument (</FONT><B><FONT FACE="Courier New">AType<SUB>T</SUB></FONT></B><FONT FACE="Bookman Old Style">)
and return at most </FONT><B><FONT FACE="Courier New">Rtype<SUB>T</SUB></FONT></B><FONT FACE="Bookman Old Style">.
More formally, </FONT><B><FONT FACE="Courier New">S</FONT></B><FONT FACE="Bookman Old Style">
must have an operation </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation F (me, a: Atype<SUB>T</SUB>) returns (Rtype<SUB>S</SUB>)</TT></B></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>where</FONT></FONT>
<BR>&nbsp;
<PRE><B><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Atype<SUB>S</SUB></TT></B><TT> is <B>Atype<SUB>T</SUB></B> or a <I>supertype</I> of <B>Atype<SUB>T</SUB></B>.&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rtype<SUB>S</SUB></B> is <B>Rtype<SUB>T</SUB></B> or a <I>subtype</I> of <B>Rtype<SUB>T</SUB></B>.</TT></PRE>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">Anywhere </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
can be invoked with an object of type </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">,
it must be able to be invoked with an object of type </FONT><B><FONT FACE="Courier New">S</FONT></B><FONT FACE="Bookman Old Style">.
The constraints on argument and return types ensure that </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
may be invoked with either type of object. Note that the constraints on
the argument types are opposite to the constraints on the result types.
This parallels the fact that arguments flow <I>into</I> the operation and
results flow <I>out of</I> the operation.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">These rules have been presented
in the context of a single supertype. When a type has multiple supertypes
(such as </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">),
the above rules must be obeyed for each supertype. </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">
must behave as both a </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
and an </FONT><B><FONT FACE="Courier New">I0_Stream</FONT></B><FONT FACE="Bookman Old Style">,
and the operations which achieve this must satisfy the subtyping constraints.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Inheritance</FONT></FONT></B>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Subtyping requires that
any operation on a type must be available on that type's subtypes. Frequently,
an operation </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
in a subtype will be identical to </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
in a supertype. After all, the subtype must provide the same behavior as
its supertypes. Trellis/Owl provides an <I>inheritance</I> mechanism which
allows a subtype to share operations with its supertypes.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>By default, a subtype inherits
the definitions in its supertypes. Only additions to the behavior of the
subtype need be specified.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">For instance, </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">
might inherit operations from </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
to move to a new position on the screen. On the other hand, an operation
to delete a line of text would be specified in </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">
because it only applies to text windows.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Inheriting a definition
from a supertype is not always appropriate. The </FONT><B><FONT FACE="Courier New">read_line</FONT></B><FONT FACE="Bookman Old Style">
operation in </FONT><B><FONT FACE="Courier New">IO_Stream</FONT></B><FONT FACE="Bookman Old Style">
probably is not implemented in a way suitable for a text window. By writing
a new definition for the operation in the subtype, inheritance of the supertype's
definition is blocked.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Invoking </FONT><B><FONT FACE="Courier New">read_line</FONT></B><FONT FACE="Bookman Old Style">
on a text window causes the </FONT><B><FONT FACE="Courier New">read_line</FONT></B><FONT FACE="Bookman Old Style">
defined in </FONT><B><FONT FACE="Courier New">Text_Window</FONT></B><FONT FACE="Bookman Old Style">
to be executed. We can see the effect of redefining the </FONT><B><FONT FACE="Courier New">read_line</FONT></B><FONT FACE="Bookman Old Style">
operation in the following code.</FONT></FONT>
<DIR>
<DIR>
<PRE><TT><B>var io: I0_Stream;</B>&nbsp;
<B>io := create (Text_Window . . .);</B>&nbsp;
<B>read_line (io);</B></TT></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">Even though </FONT><B><FONT FACE="Courier New">io</FONT></B><FONT FACE="Bookman Old Style">
is declared to be an </FONT><B><FONT FACE="Courier New">I0_Stream</FONT></B><FONT FACE="Bookman Old Style">,
the variable actually denotes a text Window and therefore the </FONT><B><FONT FACE="Courier New">Text
Window read_line</FONT></B><FONT FACE="Bookman Old Style"> is invoked.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Inheritance is straightforward
when a type has only one supertype. When a type inherits an operation </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
from more than one supertype, the possibility of an ambiguity arises. If
all of the definitions of </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
in the supertypes are identical, there is no ambiguity. If the supertypes
disagree as to the definition of </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">,
the programmer must specify the definition wanted, or write a new implementation
for </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
which supercedes the inherited </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">.
In all cases, the subtype rules must be followed.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Trellis/Owl requires the
programmer to explicitly resolve inheritance ambiguities. This enhances
the readability and the long-term maintainability of the code.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">When a new definition supersedes
a supertype's definition, it is useful to be able to invoke the supertype's
version of that definition. Suppose the supertype is </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">.
We can invoke </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">'s
version of </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
with </FONT><B><FONT FACE="Courier New">T'F(me...)</FONT></B><FONT FACE="Bookman Old Style">.
For example, the display operation in </FONT><B><FONT FACE="Courier New">Bordered_Window</FONT></B><FONT FACE="Bookman Old Style">
first calls the display operation in </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
and then draws a border around it.</FONT></FONT>
<DIR>
<DIR>
<PRE><TT><B>operation display (me)
</B><I>! Display some object in this window
! with a border around it.
</I><B>is
begin
Window'display(me); </B><I>! Use Window's display.
</I><B>display_border(me); </B><I>! Display the border.
</I><B>end;</B></TT></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">The invocation </FONT><B><FONT FACE="Courier New">Window'display</FONT></B><FONT FACE="Bookman Old Style">
can only occur in a subtype of </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Inheritance applies primarily
to public operations. Private operations are not inherited. If a public
operation </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
in type </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">
calls a private operation also in </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">,
then any inherited </FONT><B><FONT FACE="Courier New">F</FONT></B><FONT FACE="Bookman Old Style">
will still reference the private operation in </FONT><B><FONT FACE="Courier New">T</FONT></B><FONT FACE="Bookman Old Style">.
Therefore, subtype programmers need not know about the private operations
in supertypes.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Operations can have another
visibility which is not as restrictive as private but not as general as
public. This visibility is called <I>subtype-visible</I>. Subtype-visible
operations are inherited and can be redefined, but are not visible outside
the defining type and its subtypes.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Type Checking</FONT></FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>With its emphasis on user
defined types and subtypes, it is natural that Trellis/Owl should provide
type checking. Compile-time type checking can catch a significant number
of programming errors. In particular, when programs are structured around
types, many logical errors show up as type inconsistencies at compile time.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>The type checking algorithm
used in Trellis/Owl is fairly conventional. Each local variable, including
arguments, is declared to be a particular type. A variable can only be
assigned objects of its type (or some subtype of its type). Arguments to
an invocation are checked against the operation declaration. The result
type of the invocation expression is also taken from the operation declaration.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>These type checking rules
cover the interesting cases. The major difference between type checking
of expressions in Trellis/Owl and in other languages is that Trellis/Owl
uses a subtype check for assignment and operation invocation instead of
strict equality.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>A more interesting point
is that all programs are completely type checked, regardless of the order
in which operation definitions and invocations are written or compiled.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Subtype compatibility between
a type and its subtype is also completely checked.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Programmers use types and
the type hierarchy to specify how they intend objects to behave. Type checking
verifies that objects are being used in accordance with the programmer's
intent.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Type Generators</FONT></FONT></B>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Previous sections have
shown how to describe simple types. Consider designing a type </FONT><B><FONT FACE="Courier New">Set</FONT></B><FONT FACE="Bookman Old Style">.
A general kind of set would allow any sort of object to be inserted into
it. An object extracted from the set might be of any type. We would like
to be more precise about what types of objects can be placed into a particular
set. For example, we might want a set of only integers, or only strings.
A way is needed of writing a single definition for a family of related
types such as set of integers, set of strings, set of windows.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>In Trellis/Owl, a <I>type
generator</I> is a single definition for a family of almost identical types.
The type generator for a family of sets is:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>type_module Set [Element-Type: Type]

operation create (mytype)
returns (mytype);
</TT></B><TT><I>! Create a set.</I>&nbsp;

<B>operation insert (me, element: Element_Type);
</B><I>! Insert an element into the set.
</I>&nbsp;
<B>operation extract (me)
returns (Element_Type);
</B><I>! Return an arbitrary element in the set.

</I><B>end type_module;</B></TT></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">The parameter </FONT><B><FONT FACE="Courier New">Element_Type</FONT></B><FONT FACE="Bookman Old Style">
can he used throughout the type module wherever a type is needed. The type
generator </FONT><B><FONT FACE="Courier New">Set</FONT></B><FONT FACE="Bookman Old Style">
defines the types </FONT><B><FONT FACE="Courier New">Set[Integer]</FONT></B><FONT FACE="Bookman Old Style">,
</FONT><B><FONT FACE="Courier New">Set[String</FONT></B><FONT FACE="Bookman Old Style">],
</FONT><B><FONT FACE="Courier New">Set[Window]</FONT></B><FONT FACE="Bookman Old Style">,
and an unlimited number of others. The types </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">,
</FONT><B><FONT FACE="Courier New">String</FONT></B><FONT FACE="Bookman Old Style">,
and </FONT><B><FONT FACE="Courier New">Window</FONT></B><FONT FACE="Bookman Old Style">
select particular members of the </FONT><B><FONT FACE="Courier New">Set</FONT></B><FONT FACE="Bookman Old Style">
family. Individual members of a type family are known as <I>parameterized
types</I>.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Here is how </FONT><B><FONT FACE="Courier New">Set
[Integer]</FONT></B><FONT FACE="Bookman Old Style"> might be used.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>var s: Set[Integer];
var i: Integer;
s := create (Set[Integer]);
insert (s, 1);
insert (s, 2);
insert (s, "three"); </TT></B><TT><I>! Error - a string can't be
</I><B>i := 10 * extract (s); </B><I>! inserted into s.</I></TT></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>Since</FONT></FONT><I> </I><FONT SIZE=-1><B><FONT FACE="Courier New">s</FONT></B><FONT FACE="Bookman Old Style">
is a set of integers, inserting the string, </FONT><B><FONT FACE="Courier New">"three"</FONT></B><FONT FACE="Bookman Old Style">
into </FONT><B><FONT FACE="Courier New">s</FONT></B><FONT FACE="Bookman Old Style">
is not appropriate (and will be caught at compile time). By the same token,
any object extracted from </FONT><B><FONT FACE="Courier New">s</FONT></B><FONT FACE="Bookman Old Style">
is guaranteed to be an integer.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>A parameterized type can
be used like any other type. Parameterized types can be subtypes of other
types, even types within their own family.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Other Interesting Features</FONT></FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>There are a number of features
in Trellis/Owl which, although seemingly minor, significantly enhance the
expressiveness of the language. This section discusses three such features.</FONT></FONT>

<P><B><FONT FACE="Arial">Iterators</FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>In Trellis/Owl, irerators
provide the ability to extract the contents of a collection one item at
a time. Iterators are an important abstraction tool: they allow us to access
elements of a collection without revealing the implementation of the collection.
More generally, an iterator incrementally supplies a series of objects.
These objects are handled one at a time by a for expression.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">In the following example,
</FONT><B><FONT FACE="Courier New">chars</FONT></B><FONT FACE="Bookman Old Style">
is an iterator which is used to sequentially <I>yield</I> the characters
that are in a string:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>for c: Character in chars ("a string") do
&nbsp;&nbsp;&nbsp; print (c);
end for;</TT></B></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">The iterator will generate
an object in the series and </FONT><B><FONT FACE="Courier New">yield</FONT></B><FONT FACE="Bookman Old Style">
the object to the </FONT><B><FONT FACE="Courier New">for</FONT></B><FONT FACE="Bookman Old Style">
loop so that the body of the loop can execute. When the body of the </FONT><B><FONT FACE="Courier New">for</FONT></B><FONT FACE="Bookman Old Style">
loop is done, the iterator will continue and generate another object. When
the iterator has generated all the objects in the series it has finished
its work and will </FONT><B><FONT FACE="Courier New">return</FONT></B><FONT FACE="Bookman Old Style">
to the calling operation. The body of the </FONT><B><FONT FACE="Courier New">for</FONT></B><FONT FACE="Bookman Old Style">
loop executes once for each object in the series, so the iterator and the
for-loop body act like co-routines.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Here is a possible implementation
of chars:</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation chars (me)
yields (Character)
is
begin</TT></B><TT>&nbsp;
<B>&nbsp;&nbsp;&nbsp; var i: Integer : = 1;
&nbsp;&nbsp;&nbsp; loop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit when i > mc.size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield me[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i :=i+ 1;
&nbsp;&nbsp;&nbsp; end loop;
end;</B></TT></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">The </FONT><B><FONT FACE="Courier New">chars</FONT></B><FONT FACE="Bookman Old Style">
operation is a very simple iterator. It uses a loop to sequentially </FONT><B><FONT FACE="Courier New">yield</FONT></B><FONT FACE="Bookman Old Style">
the characters in the string. The notation </FONT><B><FONT FACE="Courier New">me[i]</FONT></B><FONT FACE="Bookman Old Style">
selects the i<SUP>th</SUP> character in the string. The bracket notation
is a special short form for the </FONT><B><FONT FACE="Courier New">get_indexed</FONT></B><FONT FACE="Bookman Old Style">
or </FONT><B><FONT FACE="Courier New">put_indexed</FONT></B><FONT FACE="Bookman Old Style">
operations.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>In general, iterators can
he as complex as normal operations. They can be recursive and can call
other operations including other iterators.</FONT></FONT>

<P><B><FONT FACE="Arial">Exceptions</FONT></B>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">Sometimes an operation
cannot perform its main task. For example, the </FONT><B><FONT FACE="Courier New">power</FONT></B><FONT FACE="Bookman Old Style">
operation in </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">,
designed to raise an </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">
to a power, cannot raise an </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">
to a negative power. In Trellis/Owl, the interface of an operation includes
a list of the <I>exceptions</I> that the operation can signal. This makes
for a more complete specification of the behavior of an operation.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation power (me, exponent: Integer)
returns (Integer)
signals (Negative_Exponent);</TT></B></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>Now we can account for all
possible circumstances, not just the normal completions of operations.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation power (me, exponent: Integer)
returns (Integer)
signals (Negative_Exponent)
is
begin
&nbsp;&nbsp;&nbsp; if exponent &lt; 0 then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal Negative_Exponent;
&nbsp;&nbsp;&nbsp; end if;
&nbsp;&nbsp;&nbsp; var value: Integer := l;</TT></B><TT>&nbsp;
<B>&nbsp;&nbsp;&nbsp; for count: Integer
&nbsp;&nbsp;&nbsp; in range (1, exponent) do
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value : = value * me;
&nbsp;&nbsp;&nbsp; end for;
&nbsp;&nbsp;&nbsp; return value;
end;</B></TT></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">Here the </FONT><B><FONT FACE="Courier New">power</FONT></B><FONT FACE="Bookman Old Style">
operation checks the exponent to see if it is negative. If so, the operation
signals the exception </FONT><B><FONT FACE="Courier New">Negative_Exponent</FONT></B><FONT FACE="Bookman Old Style">.
The exception could be handled in th,. following manner:</FONT></FONT>
<DIR>
<DIR>
<PRE><TT><B>begin</B>&nbsp;
<B>&nbsp;&nbsp;&nbsp; i1 := power (3, i2);
&nbsp;&nbsp;&nbsp; i3 := i1 * i4;
&nbsp;&nbsp;&nbsp; i5 := i3 / 23;
except
on Negative_Exponent do
&nbsp;&nbsp;&nbsp; print ("error - negative exponent");
end;</B></TT></PRE>
</DIR>
</DIR>
<FONT FACE="Bookman Old Style"><FONT SIZE=-1>Note that the exception handling
code is separated from the main line of code, enhancing readability.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>An object can be passed
back with the exception and used in the handler. This object can provide
further details about the error.</FONT></FONT>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">The caller of an operation
has the responsibility for handling any exception that can be signalled
by the operation. If the caller does not want to handle a particular exception,
he can </FONT><B><FONT FACE="Courier New">resignal</FONT></B><FONT FACE="Bookman Old Style">
the exception. This puts the responsiblity for handling the exception on
his caller.</FONT></FONT>

<P><B><FONT FACE="Arial">Type cases</FONT></B>

<P><FONT SIZE=-1><FONT FACE="Bookman Old Style">We have noted that Trellis/Owl
makes strong use of compile-time type checking. It is also possible to
test the types of objects at run-time by using the <I>type_case</I> expression.
This example is an add operation for </FONT><B><FONT FACE="Courier New">Real</FONT></B><FONT FACE="Bookman Old Style">
which accepts a complex number for a second argument. It assumes that </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">
and </FONT><B><FONT FACE="Courier New">Real</FONT></B><FONT FACE="Bookman Old Style">
are subtypes of </FONT><B><FONT FACE="Courier New">Complex</FONT></B><FONT FACE="Bookman Old Style">.</FONT></FONT>
<DIR>
<DIR>
<PRE><B><TT>operation add (me, addend: Complex)
returns (Complex)
! Add an Integer, Real or Complex number to a real.
! Operation primitive_add adds two real numbers.
is</TT></B><TT>&nbsp;
<B>begin
&nbsp;&nbsp;&nbsp; type_case addend
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on Integer do
</B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! Convert the integer to a real and add.
</I><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primitive_add (me.convert (Real. selector_value))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on Real do
</B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! No conversion needed, just add.
</I><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; primitive_add (me, selector_value)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherwise do
</B><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! The addend must be complex,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! let Complex's add do it.
</I><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add (selector_value, me)
&nbsp;&nbsp;&nbsp; end type_case;
end;</B></TT></PRE>
</DIR>
</DIR>
<FONT SIZE=-1><FONT FACE="Bookman Old Style">The variable </FONT><B><FONT FACE="Courier New">selector_value</FONT></B><FONT FACE="Bookman Old Style">
has a value only within the type case and gets its value from </FONT><B><FONT FACE="Courier New">addend</FONT></B><FONT FACE="Bookman Old Style">.
The type of </FONT><B><FONT FACE="Courier New">selector_value</FONT></B><FONT FACE="Bookman Old Style">
depends on which case arm it is in; it is an integer in the </FONT><B><FONT FACE="Courier New">Integer</FONT></B><FONT FACE="Bookman Old Style">
case arm, real in the </FONT><B><FONT FACE="Courier New">Real</FONT></B><FONT FACE="Bookman Old Style">
case arm, and defaults to the type of </FONT><B><FONT FACE="Courier New">addend</FONT></B><FONT FACE="Bookman Old Style">
in the </FONT><B><FONT FACE="Courier New">otherwise</FONT></B><FONT FACE="Bookman Old Style">
case arm.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Experience</FONT></FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>We have now had about two
years of experience with the language. It has been used to implement the
Trellis programming environment, which is used to develop Trellis/Owl programs.
We have found the object-based approach to be extremely useful in the design
and implementation phases of a project. As with any research project, we
have done as much re-design as design. The encapsulation offered by objects
and types was a great help here in making major changes much easier. The
type hierarchy and multiple inheritance were used extensively in the Trellis
environment and have proven themselves to be very useful.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>From the start of the project,
there has been an emphasis on getting good performance from the language.
Our entire multiple-window environment is written in Trellis/Owl and offers
excellent performance on a standard 1-mips workstation. We attribute this
performance to our attention to compile-time checking and the efficient
generation of direct code for operation invocation.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Although we have not been
using the language long enough to substantiate our claim that Trellis/Owl
programs will be easier to maintain and evolve, our experience to date
with parts of the environment is very positive. We hope to report on this
in the future.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>Conclusions</FONT></FONT></B>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>This paper is a brief introduction
to the Trellis/Owl language. We have presented the most important language
concepts but have omitted a number of language features as well as several
details on the concepts covered. Further information on the language may
be found in [Schaffert 85] and [O'Brien 85]- Copies of these are available
from the Object-Based Systems Group.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>Our experience with the
implementation and use of the language has shown that not only were the
design goals and resulting language concepts independently important but
that they enhance one another when combined.</FONT></FONT>

<P><B><FONT FACE="Arial"><FONT SIZE=+1>References</FONT></FONT></B>
<DIR>
<DIR>
<DIR>
<DIR><FONT FACE="Bookman Old Style"><FONT SIZE=-1>[Bornlng 82] Alan Bornlng
and Daniel Ingalls, "Multiple Inheritance in Smalltalk-80, proceedings
of the National Conference on Artificial Intelligence, Pittsburgh, PA,
1982.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>[Goldberg 83] Adele Goldberg
and David Robson, Smalltalk-80: The Language and its Implementation, Addison-Wesley,
Reading, Massachusetts, 1983.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>[Liskov 81] B. Liskov,
R. Atkinson, T. Bloom, E. Moss, C. Schaffert, R. Scheifler, and A. Snyder,
CLU Reference Manual, Springer-Verlag, 1981.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>[Liskov 77] B. Liskov,
A. Shyder, R. Atkinson, and C. Schaffert, "Abstraction Mechanisms in CLU',
Communications of the A GM 20(8), August 1977.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>[O'Brien 85] Patrick O'Brien,
Trellis Object-Based Environment: Language Tutorial, Digital Equipment
Corporation Technical Report DEC-TR-373, November 1985.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>[Schaffert 85] Craig Schaffert,
Topher Cooper, and Carrie Wilpolt, Trellis Object-Based Environment: Language
Manual, Digital Equipment Corporation Technical Report DECTR-372, November
1985.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>[Weinreb 81] Daniel Weinreb
and David Moon, Lisp Machine Manual, Symbolics, Inc., 1981.</FONT></FONT>

<P><FONT FACE="Bookman Old Style"><FONT SIZE=-1>&nbsp;</FONT></FONT></DIR>
</DIR>
</DIR>
</DIR>

</BODY>
</HTML>
